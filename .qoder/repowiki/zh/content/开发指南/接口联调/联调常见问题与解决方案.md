# 联调常见问题与解决方案

<cite>
**本文档引用文件**  
- [auth.ts](file://backend/src/middleware/auth.ts)
- [dio_client.dart](file://flutter_app/lib/core/network/dio_client.dart)
- [nginx.conf](file://home/user/nian/admin-web/nginx.conf)
- [upload.ts](file://backend/src/utils/upload.ts)
- [api_constants.dart](file://flutter_app/lib/config/api_constants.dart)
- [admin.controller.ts](file://backend/src/controllers/admin.controller.ts)
- [auth.controller.ts](file://backend/src/controllers/auth.controller.ts)
- [practice.controller.ts](file://backend/src/controllers/practice.controller.ts)
- [practice_record_model.dart](file://flutter_app/lib/data/models/practice_record_model.dart)
- [date_formatter.dart](file://flutter_app/lib/core/utils/date_formatter.dart)
- [errorHandler.ts](file://backend/src/middleware/errorHandler.ts)
- [MediaLibrary.tsx](file://home/user/nian/admin-web/src/pages/MediaLibrary.tsx)
</cite>

## 目录
1. [CORS跨域问题](#cors跨域问题)
2. [JWT令牌过期或验证失败](#jwt令牌过期或验证失败)
3. [请求参数格式错误](#请求参数格式错误)
4. [文件上传路径异常](#文件上传路径异常)
5. [调试方法与工具](#调试方法与工具)

## CORS跨域问题

在前后端分离架构中，前端应用（如管理后台）运行在 `localhost:5173`，而后端API运行在 `localhost:3000`，这会导致浏览器的同源策略阻止跨域请求。当前项目中，Nginx作为反向代理服务器，负责将前端请求代理到后端服务。

通过分析 `nginx.conf` 文件发现，当前配置中缺少必要的CORS响应头，导致浏览器拒绝响应。虽然Nginx已正确配置了API代理规则，但未显式设置 `Access-Control-Allow-Origin` 等CORS相关头信息。

**解决方案**：在Nginx配置中添加CORS响应头，允许指定来源的请求。以下是修复后的配置示例：

```nginx
location /api {
    proxy_pass http://backend:3000;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection 'upgrade';
    proxy_set_header Host $host;
    proxy_cache_bypass $http_upgrade;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    # 添加CORS头
    add_header Access-Control-Allow-Origin * always;
    add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
    add_header Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization" always;
    add_header Access-Control-Expose-Headers "Content-Length, Content-Range" always;
}
```

此外，对于预检请求（OPTIONS），需要单独处理：

```nginx
if ($request_method = 'OPTIONS') {
    add_header Access-Control-Allow-Origin *;
    add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
    add_header Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization";
    add_header Content-Length 0;
    add_header Content-Type text/plain;
    return 204;
}
```

**调试方法**：
- 使用浏览器开发者工具的Network面板，检查请求的Request Headers和Response Headers
- 查看是否包含 `Origin` 请求头和 `Access-Control-Allow-Origin` 响应头
- 检查控制台是否出现CORS相关错误信息

**Section sources**
- [nginx.conf](file://home/user/nian/admin-web/nginx.conf#L1-L69)

## JWT令牌过期或验证失败

JWT（JSON Web Token）是本项目用于用户认证的核心机制。前端在登录成功后获取JWT令牌，并在后续请求中通过 `Authorization: Bearer <token>` 头发送。后端通过 `auth.ts` 中间件验证令牌的有效性。

### 问题根因分析

1. **令牌过期**：当前配置中，JWT令牌的默认有效期为7天（由 `JWT_EXPIRES_IN` 环境变量控制）。当令牌过期后，后端会返回401状态码。
2. **令牌解析失败**：可能由于令牌被篡改、签名密钥不匹配或令牌格式错误导致。
3. **客户端存储问题**：Flutter应用使用 `flutter_secure_storage` 存储令牌，若存储失败或读取异常，会导致认证失败。

### 解决方案

**后端修复**：在 `auth.ts` 中，`generateToken` 函数已正确实现令牌生成，但建议增加更灵活的过期时间配置：

```typescript
export const generateToken = (payload: object, expiresIn?: string): string => {
  return jwt.sign(
    payload,
    JWT_SECRET,
    { expiresIn: expiresIn || process.env.JWT_EXPIRES_IN || '1d' } // 建议缩短为1天提高安全性
  );
};
```

**前端修复**：在 `dio_client.dart` 中，`_AuthInterceptor` 已正确实现从安全存储读取令牌并添加到请求头的逻辑。同时，`_ErrorInterceptor` 在收到401响应时会自动清除过期令牌：

```dart
if (err.response?.statusCode == 401) {
  // 清除过期令牌
  _secureStorage.delete(key: 'auth_token');
  AppLogger.warning('认证失败，令牌已过期或无效');
}
```

**调试方法**：
- 检查后端日志，查看认证失败的具体原因
- 使用Dio的日志拦截器查看请求和响应详情
- 在浏览器Network面板中检查请求头是否包含正确的Authorization头
- 验证令牌的JWT格式是否正确（三段式，用点分隔）

**Section sources**
- [auth.ts](file://backend/src/middleware/auth.ts#L6-L87)
- [dio_client.dart](file://flutter_app/lib/core/network/dio_client.dart#L63-L97)
- [auth.controller.ts](file://backend/src/controllers/auth.controller.ts#L52-L53)
- [errorHandler.ts](file://backend/src/middleware/errorHandler.ts#L28-L36)

## 请求参数格式错误

请求参数格式错误是联调过程中常见的问题，主要体现在日期序列化不一致和嵌套对象编码问题。

### 日期序列化不一致

后端使用JavaScript的 `Date` 对象，而前端Flutter使用 `DateTime` 对象。两者在序列化为JSON时可能存在格式差异。

通过分析 `practice_record_model.dart` 文件，发现模型类使用 `toIso8601String()` 方法进行序列化：

```dart
practicedAt: practicedAt.toIso8601String(),
```

后端在接收时使用 `DateTime.parse()` 进行解析，这要求日期格式必须符合ISO 8601标准。

**解决方案**：确保前后端统一使用ISO 8601格式。在Flutter端，始终使用 `toIso8601String()`；在后端，使用统一的日期解析函数：

```typescript
// 后端统一日期解析
const parseDate = (dateString: string): Date => {
  return new Date(dateString);
};
```

**调试方法**：
- 使用 `date_formatter.dart` 中的 `parseDate` 方法支持多种日期格式
- 在Dio客户端中添加请求转换器，统一处理日期格式

```dart
// 在DioClient中配置transformRequest
_dio.transformer = DefaultTransformer(
  jsonEncodeCallback: (data) {
    // 递归处理所有DateTime对象
    return jsonEncode(data, toEncodable: (dynamic item) {
      if (item is DateTime) {
        return item.toIso8601String();
      }
      return item;
    });
  },
);
```

### 嵌套对象编码问题

当请求体包含嵌套对象时，需要确保JSON序列化正确。例如，练习记录中的 `questionnaire_result` 字段可能是一个复杂对象。

**解决方案**：确保对象的 `toJson()` 方法正确实现。在 `practice_record_model.dart` 中：

```dart
Map<String, dynamic> toJson() {
  return {
    'id': id,
    'userId': userId,
    'methodId': methodId,
    'durationMinutes': durationMinutes,
    'moodBefore': moodBefore,
    'moodAfter': moodAfter,
    'notes': notes,
    'practicedAt': practicedAt.toIso8601String(),
  };
}
```

**调试方法**：
- 使用Dio的日志拦截器查看实际发送的请求数据
- 在后端使用 `AppLogger.debug('请求数据: ${options.data}');` 查看接收到的数据
- 验证JSON结构是否符合API文档要求

**Section sources**
- [practice_record_model.dart](file://flutter_app/lib/data/models/practice_record_model.dart#L34-L45)
- [date_formatter.dart](file://flutter_app/lib/core/utils/date_formatter.dart#L201-L232)
- [dio_client.dart](file://flutter_app/lib/core/network/dio_client.dart#L111-L113)
- [practice.controller.ts](file://backend/src/controllers/practice.controller.ts#L6-L261)

## 文件上传路径异常

文件上传功能涉及前端、Nginx和后端服务的协同工作。常见问题包括上传目录权限不足和Nginx静态资源映射配置错误。

### 问题根因分析

1. **上传目录权限**：后端使用 `uploads` 目录存储上传文件。如果该目录不存在或权限不足，会导致上传失败。
2. **Nginx静态资源映射**：Nginx需要正确配置静态资源路径，以便能够访问上传的文件。
3. **文件路径生成**：后端生成的文件URL路径需要与Nginx的静态资源配置匹配。

### 解决方案

**后端修复**：在 `upload.ts` 中，已正确实现目录创建和权限管理：

```typescript
// 确保上传目录存在
const uploadsDir = path.join(process.cwd(), 'uploads');
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}
```

文件存储路径按年月组织，避免单目录文件过多：

```typescript
const getUploadPath = (): string => {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const uploadPath = path.join(uploadsDir, String(year), month);
  
  if (!fs.existsSync(uploadPath)) {
    fs.mkdirSync(uploadPath, { recursive: true });
  }
  
  return uploadPath;
};
```

**Nginx配置**：需要添加静态资源映射规则：

```nginx
# 静态文件服务
location /uploads/ {
    alias /app/uploads/;
    expires 1y;
    add_header Cache-Control "public, immutable";
}
```

**前端修复**：在 `MediaLibrary.tsx` 中，上传组件正确配置了action URL：

```typescript
action: `${import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000'}/api/admin/upload`,
```

**调试方法**：
- 检查服务器上 `uploads` 目录的权限（建议755）
- 验证上传后文件是否实际写入磁盘
- 通过浏览器直接访问文件URL测试Nginx静态资源配置
- 查看Nginx错误日志和后端日志

**Section sources**
- [upload.ts](file://backend/src/utils/upload.ts#L7-L127)
- [admin.controller.ts](file://backend/src/controllers/admin.controller.ts#L480-L512)
- [nginx.conf](file://home/user/nian/admin-web/nginx.conf#L29-L33)
- [MediaLibrary.tsx](file://home/user/nian/admin-web/src/pages/MediaLibrary.tsx#L127-L130)

## 调试方法与工具

有效的调试方法是快速定位和解决联调问题的关键。

### 后端日志追踪

后端使用自定义日志系统，在 `errorHandler.ts` 中记录所有错误：

```typescript
export const errorHandler = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  logger.error('Error occurred:', {
    error: err.message,
    stack: err.stack,
    path: req.path,
    method: req.method,
  });
  // ... 处理逻辑
};
```

**最佳实践**：
- 记录请求路径、方法、参数和响应状态
- 记录详细的错误堆栈信息
- 区分开发环境和生产环境的日志级别

### Dio日志输出

Flutter端使用Dio拦截器实现详细的网络日志记录：

```dart
class _LogInterceptor extends Interceptor {
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    AppLogger.info('[$method] 请求: $url');
    AppLogger.debug('请求数据: ${options.data}');
    AppLogger.debug('查询参数: ${options.queryParameters}');
    handler.next(options);
  }
  
  @override
  void onResponse(Response response, ResponseInterceptorHandler handler) {
    AppLogger.network(method, url, statusCode: statusCode);
    AppLogger.debug('响应数据: ${response.data}');
    handler.next(response);
  }
}
```

### 浏览器Network面板分析

使用浏览器开发者工具的Network面板进行调试：

1. **查看请求详情**：检查请求URL、方法、头信息和请求体
2. **分析响应**：查看响应状态码、头信息和响应体
3. **性能分析**：查看请求耗时，识别性能瓶颈
4. **CORS检查**：验证预检请求和响应头

**调试流程**：
1. 复现问题
2. 打开开发者工具
3. 在Network面板中找到相关请求
4. 检查请求和响应的各个部分
5. 根据错误信息定位问题根源

**Section sources**
- [errorHandler.ts](file://backend/src/middleware/errorHandler.ts#L21-L47)
- [dio_client.dart](file://flutter_app/lib/core/network/dio_client.dart#L103-L154)
- [app_logger.dart](file://flutter_app/lib/core/utils/app_logger.dart#L107-L131)